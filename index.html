<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D CubeCatcher</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
      color: white;
      font-family: 'Arial', sans-serif;
      touch-action: manipulation;
      height: 100%;
    }
    canvas {
      display: block;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    #score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0,0,0,0.7);
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      border-radius: 20px;
    }
    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 20;
    }
    h1 {
      font-size: 3em;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      color: #ff8c00;
      text-align: center;
    }
    button {
      background: linear-gradient(to bottom, #ff8c00, #ff2d00);
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 30px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      margin-top: 20px;
    }
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    button:active {
      transform: translateY(1px);
    }
    #game-over {
      display: none;
    }
    #final-score {
      font-size: 2em;
      margin: 20px 0;
    }
    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    #instructions {
      max-width: 80%;
      text-align: center;
      margin-bottom: 30px;
      line-height: 1.5;
    }
    #high-score {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0,0,0,0.7);
      background: rgba(0,0,0,0.5);
      padding: 8px 16px;
      border-radius: 15px;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="score">0</div>
  <div id="high-score">High Score: 0</div>
</div>

<div id="start-screen">
  <h1>3D CubeCatcher</h1>
  <div id="instructions">
    Catch the falling cubes with your basketball hoop!<br>
    Move your finger or mouse to control the hoop.<br>
    Bigger cubes are worth more points!
  </div>
  <button id="start-btn">Start Game</button>
</div>

<div id="game-over">
  <h1>Game Over</h1>
  <div id="final-score">Score: 0</div>
  <button id="restart-btn">Play Again</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
<script>
  // Game elements
  let scene, camera, renderer;
  let score = 0;
  let highScore = localStorage.getItem('highScore') || 0;
  let gameRunning = false;
  let animationFrameId;
  let lastSpawnTime = 0;
  
  // Game objects
  let ring, ringNet;
  let cubes = [];
  let particles = [];
  let stars = [];
  
  // DOM elements
  const scoreElement = document.getElementById('score');
  const highScoreElement = document.getElementById('high-score');
  const startScreen = document.getElementById('start-screen');
  const gameOverScreen = document.getElementById('game-over');
  const finalScoreElement = document.getElementById('final-score');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');
  
  // Initialize Three.js scene
  function init() {
    // Create scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f0c29);
    
    // Add fog for depth effect
    scene.fog = new THREE.FogExp2(0x0f0c29, 0.002);
    
    // Create camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 300);
    camera.lookAt(0, 0, 0);
    
    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    
    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);
    
    // Add hemisphere light for natural lighting
    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
    scene.add(hemisphereLight);
    
    // Create basketball hoop
    createBasketballHoop();
    
    // Create stars background
    createStarfield();
    
    // Set initial high score display
    highScoreElement.textContent = `High Score: ${highScore}`;
    
    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    
    // Handle controls
    setupControls();
  }
  
  function createBasketballHoop() {
    // Backboard
    const backboardGeometry = new THREE.BoxGeometry(120, 80, 5);
    const backboardMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
    backboard.position.set(0, 100, -50);
    backboard.castShadow = true;
    scene.add(backboard);
    
    // Rim (outer)
    const rimGeometry = new THREE.TorusGeometry(25, 3, 16, 32);
    const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff5722 });
    ring = new THREE.Mesh(rimGeometry, rimMaterial);
    ring.position.set(0, 50, -50);
    ring.rotation.x = Math.PI / 2;
    ring.castShadow = true;
    scene.add(ring);
    
    // Rim (inner)
    const innerRimGeometry = new THREE.TorusGeometry(24, 1, 16, 32);
    const innerRimMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
    const innerRim = new THREE.Mesh(innerRimGeometry, innerRimMaterial);
    innerRim.position.set(0, 50, -50);
    innerRim.rotation.x = Math.PI / 2;
    scene.add(innerRim);
    
    // Net
    createNet();
    
    // Support pole
    const poleGeometry = new THREE.CylinderGeometry(3, 3, 150, 16);
    const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
    pole.position.set(0, -25, -50);
    pole.castShadow = true;
    scene.add(pole);
  }
  
  function createNet() {
    const netMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xffffff,
      transparent: true,
      opacity: 0.6,
      wireframe: true
    });
    
    const netGeometry = new THREE.ConeGeometry(25, 60, 16, 8, true);
    ringNet = new THREE.Mesh(netGeometry, netMaterial);
    ringNet.position.set(0, 20, -50);
    ringNet.rotation.x = Math.PI;
    scene.add(ringNet);
  }
  
  function createStarfield() {
    const starGeometry = new THREE.BufferGeometry();
    const starMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 1,
      transparent: true,
      opacity: 0.8
    });
    
    const starVertices = [];
    for (let i = 0; i < 1000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starVertices.push(x, y, z);
    }
    
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const starField = new THREE.Points(starGeometry, starMaterial);
    scene.add(starField);
  }
  
  function spawnCube() {
    const size = 10 + Math.random() * 20;
    const colors = [
      0xff5252, 0xffeb3b, 0x4caf50, 
      0x2196f3, 0x9c27b0, 0xff9800,
      0x00bcd4, 0xe91e63
    ];
    const color = colors[Math.floor(Math.random() * colors.length)];
    
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshPhongMaterial({ 
      color: color,
      shininess: 100
    });
    
    const cube = new THREE.Mesh(geometry, material);
    cube.castShadow = true;
    cube.receiveShadow = true;
    
    // Set random position above the screen
    cube.position.x = (Math.random() - 0.5) * 300;
    cube.position.y = 200;
    cube.position.z = (Math.random() - 0.5) * 100;
    
    // Set random rotation
    cube.rotation.x = Math.random() * Math.PI;
    cube.rotation.y = Math.random() * Math.PI;
    
    // Add physics properties
    cube.userData = {
      speed: 1 + Math.random() * 3,
      rotationSpeed: {
        x: (Math.random() - 0.5) * 0.05,
        y: (Math.random() - 0.5) * 0.05,
        z: (Math.random() - 0.5) * 0.05
      },
      points: Math.ceil(size / 5),
      color: color
    };
    
    scene.add(cube);
    cubes.push(cube);
  }
  
  function createParticles(position, color, count) {
    const particleGeometry = new THREE.BufferGeometry();
    const particleMaterial = new THREE.PointsMaterial({
      color: color,
      size: 3,
      transparent: true,
      opacity: 1,
      blending: THREE.AdditiveBlending
    });
    
    const particlePositions = [];
    const particleSizes = [];
    const particleAlphas = [];
    
    for (let i = 0; i < count; i++) {
      // Position
      particlePositions.push(
        position.x + (Math.random() - 0.5) * 20,
        position.y + (Math.random() - 0.5) * 20,
        position.z + (Math.random() - 0.5) * 20
      );
      
      // Size
      particleSizes.push(Math.random() * 4 + 1);
      
      // Alpha
      particleAlphas.push(1);
    }
    
    particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.Float32BufferAttribute(particleSizes, 1));
    particleGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(particleAlphas, 1));
    
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    particleSystem.userData = {
      life: 60,
      velocity: Array(count).fill().map(() => ({
        x: (Math.random() - 0.5) * 3,
        y: (Math.random() - 0.5) * 3,
        z: (Math.random() - 0.5) * 3
      }))
    };
    
    scene.add(particleSystem);
    particles.push(particleSystem);
  }
  
  function update() {
    const now = Date.now();
    
    // Spawn new cubes periodically
    if (gameRunning && now - lastSpawnTime > 700 - Math.min(score, 500) / 2) {
      spawnCube();
      lastSpawnTime = now;
    }
    
    // Update cubes
    for (let i = cubes.length - 1; i >= 0; i--) {
      const cube = cubes[i];
      
      // Update position
      cube.position.y -= cube.userData.speed;
      
      // Update rotation
      cube.rotation.x += cube.userData.rotationSpeed.x;
      cube.rotation.y += cube.userData.rotationSpeed.y;
      cube.rotation.z += cube.userData.rotationSpeed.z;
      
      // Check collision with ring
      const distance = cube.position.distanceTo(new THREE.Vector3(ring.position.x, ring.position.y, ring.position.z));
      
      if (distance < 30 && cube.position.y < ring.position.y + 10) {
        // Cube caught!
        createParticles(cube.position, cube.userData.color, 30);
        scene.remove(cube);
        cubes.splice(i, 1);
        
        score += cube.userData.points;
        scoreElement.textContent = score;
        
        // Animate score
        scoreElement.style.transform = 'translateX(-50%) scale(1.2)';
        setTimeout(() => {
          scoreElement.style.transform = 'translateX(-50%) scale(1)';
        }, 200);
      } else if (cube.position.y < -200) {
        // Cube missed - game over
        scene.remove(cube);
        cubes.splice(i, 1);
        if (gameRunning) {
          gameOver();
        }
      }
    }
    
    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const particleSystem = particles[i];
      const positions = particleSystem.geometry.attributes.position.array;
      const alphas = particleSystem.geometry.attributes.alpha.array;
      const velocities = particleSystem.userData.velocity;
      
      // Update each particle
      for (let j = 0; j < positions.length; j += 3) {
        positions[j] += velocities[j/3].x;
        positions[j+1] += velocities[j/3].y;
        positions[j+2] += velocities[j/3].z;
        
        // Apply gravity
        velocities[j/3].y -= 0.05;
        
        // Fade out
        alphas[j/3] = particleSystem.userData.life / 60;
      }
      
      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.geometry.attributes.alpha.needsUpdate = true;
      
      particleSystem.userData.life--;
      
      if (particleSystem.userData.life <= 0) {
        scene.remove(particleSystem);
        particles.splice(i, 1);
      }
    }
    
    // Animate net slightly
    if (ringNet) {
      ringNet.rotation.z = Math.sin(Date.now() * 0.005) * 0.1;
    }
    
    // Render scene
    renderer.render(scene, camera);
    
    if (gameRunning) {
      animationFrameId = requestAnimationFrame(update);
    }
  }
  
  function setupControls() {
    // Mouse/touch controls for moving the ring
    let targetX = 0;
    
    function handleMove(clientX) {
      if (!gameRunning) return;
      
      // Convert screen coordinates to world coordinates
      const x = (clientX / window.innerWidth) * 2 - 1;
      targetX = x * 150; // Scale to world coordinates
    }
    
    // Smooth movement
    function smoothMove() {
      if (ring) {
        ring.position.x += (targetX - ring.position.x) * 0.1;
        ringNet.position.x = ring.position.x;
      }
      requestAnimationFrame(smoothMove);
    }
    smoothMove();
    
    // Event listeners
    renderer.domElement.addEventListener('mousemove', (e) => {
      handleMove(e.clientX);
    });
    
    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      handleMove(e.touches[0].clientX);
    }, { passive: false });
  }
  
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  function startGame() {
    // Reset score
    score = 0;
    scoreElement.textContent = score;
    
    // Clear existing cubes and particles
    cubes.forEach(cube => scene.remove(cube));
    cubes = [];
    particles.forEach(particle => scene.remove(particle));
    particles = [];
    
    // Reset game state
    gameRunning = true;
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    lastSpawnTime = Date.now();
    
    // Start game loop
    update();
  }
  
  function gameOver() {
    gameRunning = false;
    finalScoreElement.textContent = `Score: ${score}`;
    gameOverScreen.style.display = 'flex';
    
    // Update high score
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('highScore', highScore);
      highScoreElement.textContent = `High Score: ${highScore}`;
    }
    
    cancelAnimationFrame(animationFrameId);
  }
  
  // Event listeners for buttons
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', startGame);
  
  // Initialize the game
  init();
  
  // For Telegram Mini App integration
  if (window.Telegram && window.Telegram.WebApp) {
    // Expand the app to full viewport
    Telegram.WebApp.expand();
    
    // Change background color to match Telegram theme
    document.body.style.background = Telegram.WebApp.themeParams.bg_color || 'linear-gradient(to bottom, #0f0c29, #302b63, #24243e)';
    
    // Adjust text color based on theme
    const textColor = Telegram.WebApp.themeParams.text_color || 'white';
    document.body.style.color = textColor;
    document.querySelector('h1').style.color = textColor;
    
    // Handle back button
    Telegram.WebApp.BackButton.onClick(() => {
      if (gameRunning) {
        gameOver();
      } else {
        Telegram.WebApp.close();
      }
    });
    
    // Show back button when game starts
    startBtn.addEventListener('click', () => {
      Telegram.WebApp.BackButton.show();
    });
  }
</script>
</body>
</html>
