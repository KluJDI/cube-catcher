<!DOCTYPE html>
<html lang="ru">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <title>–õ–æ–≤–∏ –ú–µ–º—ã —Å –ë–æ–º–±–∞–º–∏!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>

    /* iOS-specific fixes */
  @supports (-webkit-touch-callout: none) {
    /* –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è Safari –Ω–∞ iOS */
    body {
      -webkit-text-stroke: 0.5px transparent; /* –£–ª—É—á—à–∞–µ—Ç —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥ —à—Ä–∏—Ñ—Ç–æ–≤ */
      text-shadow: 0 0 1px rgba(0,0,0,0.1); /* –ß—É—Ç—å —É–ª—É—á—à–∞–µ—Ç —á–∏—Ç–∞–µ–º–æ—Å—Ç—å */
    }
    
    /* –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
    #score, #lives {
      font-size: 22px !important;
      padding: 12px 24px !important;
    }
    
    #high-score {
      font-size: 18px !important;
    }
    
    h1 {
      font-size: 32px !important;
      line-height: 1.2;
    }
    
    button {
      font-size: 20px !important;
      padding: 16px 32px !important;
    }
    
    #instructions {
      font-size: 16px !important;
      line-height: 1.5;
    }
    
    .meme-text {
      font-size: 18px !important;
    }
  }

  /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö */
  @media (max-width: 768px) {
    #score, #lives {
      position: fixed !important;
      top: 10px !important;
    }
    
    #lives {
      left: 10px !important;
      right: auto !important;
    }
    
    #high-score {
      top: 60px !important;
    }
    
    /* –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ–±–ª–∞—Å—Ç—å –∫–∞—Å–∞–Ω–∏—è –¥–ª—è –∫–Ω–æ–ø–æ–∫ */
    button {
      min-width: 200px;
      padding: 15px 0 !important;
    }
  }


    
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* –í–∞—à–µ —Ñ–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ */
      background: url('https://i.ytimg.com/vi/1qiuIpSqkfo/maxresdefault.jpg') no-repeat center center fixed;
      background-size: cover;
      color: white;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      touch-action: manipulation;
      height: 100%;
      -webkit-text-size-adjust: 100%; /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∞–≤—Ç–æ-–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ */
    }
    canvas {
      display: block;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }
    #score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000, -2px -2px 0 #000;
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      border-radius: 20px;
      border: 3px dashed yellow;
    }
    #lives {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      background: rgba(0,0,0,0.5);
      padding: 10px 15px;
      border-radius: 20px;
      border: 3px solid red;
    }
    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      z-index: 20;
      text-align: center;
    }
    h1 {
      font-size: 3em;
      margin-bottom: 20px;
      text-shadow: 3px 3px 0 #ff00cc, -3px -3px 0 #00ccff;
      color: #ffff00;
      animation: rainbow 2s infinite;
    }
    @keyframes rainbow {
      0% { color: #ff0000; }
      14% { color: #ff7f00; }
      28% { color: #ffff00; }
      42% { color: #00ff00; }
      57% { color: #0000ff; }
      71% { color: #4b0082; }
      85% { color: #9400d3; }
      100% { color: #ff0000; }
    }
    button {
      background: linear-gradient(to bottom, #ff00cc, #00ccff);
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 1.5em;
      border-radius: 50px;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
      transition: transform 0.3s, box-shadow 0.3s;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      font-weight: bold;
      text-transform: uppercase;
      margin-top: 30px;
      border: 3px solid white;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    button:hover {
      transform: scale(1.1) rotate(5deg);
      box-shadow: 0 15px 30px rgba(0,0,0,0.4);
    }
    button:active {
      transform: scale(0.9) rotate(-5deg);
    }
    #game-over {
      display: none;
    }
    #final-score {
      font-size: 2.5em;
      margin: 30px 0;
      text-shadow: 2px 2px 0 #000;
      color: #00ff00;
      animation: bounce 0.5s infinite alternate;
    }
    @keyframes bounce {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }
    #instructions {
      max-width: 80%;
      text-align: center;
      margin-bottom: 30px;
      line-height: 1.6;
      font-size: 1.2em;
      text-shadow: 1px 1px 0 #000;
      color: #ffff00;
    }
    #high-score {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.5em;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      border-radius: 15px;
      border: 2px dotted white;
    }
    .meme-text {
      position: absolute;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
      animation: float-up 3s forwards;
    }
    @keyframes float-up {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-100px); opacity: 0; }
    }
    .explosion {
      position: absolute;
      width: 100px;
      height: 100px;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255,100,0,0.8) 0%, rgba(255,0,0,0) 70%);
      border-radius: 50%;
      transform: scale(0);
      animation: explode 0.5s forwards;
    }
    @keyframes explode {
      to { transform: scale(3); opacity: 0; }
    }

    #music-toggle {
  transition: all 0.3s ease;
}
#music-toggle:hover {
  transform: scale(1.1);
  background: rgba(0,0,0,0.7) !important;
}
  </style>
</head>
<body>
<div id="ui">
  <div id="score">0 –ú–ï–ú–û–í</div>
  <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  <div id="high-score">–†–µ–∫–æ—Ä–¥: 0</div>
</div>

<div id="start-screen">
  <h1>–õ–û–í–ò –ú–ï–ú–´!</h1>
  <div id="instructions">
    –õ–æ–≤–∏ –ø–∞–¥–∞—é—â–∏–µ –º–µ–º—ã –≤–µ–¥—Ä–æ–º!<br>
    –ò–∑–±–µ–≥–∞–π –±–æ–º–± - –æ–Ω–∏ –æ—Ç–Ω–∏–º–∞—é—Ç –∂–∏–∑–Ω–∏!<br>
    –ß–µ–º —Ä–µ–∂–µ –º–µ–º - —Ç–µ–º –±–æ–ª—å—à–µ –æ—á–∫–æ–≤!<br>
    <span style="font-size: 0.8em;">(–ü—Ä–æ—Å—Ç–æ –¥–≤–∏–≥–∞–π –ø–∞–ª—å—Ü–µ–º/–º—ã—à–∫–æ–π)</span>
  </div>
  <button id="start-btn">–ü–û–ì–ù–ê–õ–ò!</button>
</div>

<div id="game-over">
  <h1>–ö–û–ù–ï–¶ –ò–ì–†–´</h1>
  <div id="final-score">–ü–æ–π–º–∞–Ω–æ: 0 –º–µ–º–æ–≤</div>
  <button id="restart-btn">–ï–©–Å –†–ê–ó!</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
  // Game elements
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const livesElement = document.getElementById('lives');
  const highScoreElement = document.getElementById('high-score');
  const startScreen = document.getElementById('start-screen');
  const gameOverScreen = document.getElementById('game-over');
  const finalScoreElement = document.getElementById('final-score');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');
  
  // Game state
  let score = 0;
  let lives = 3;
  let highScore = localStorage.getItem('memeHighScore') || 0;
  let gameRunning = false;
  let animationFrameId;
  let lastSpawnTime = 0;

  // ===== –î–û–ë–ê–í–¨–¢–ï –≠–¢–û –ü–†–Ø–ú–û –ó–î–ï–°–¨ =====
  // –§–æ–Ω–æ–≤–∞—è –º—É–∑—ã–∫–∞
  const backgroundMusic = new Audio('sounds/background-music.mp3');
  backgroundMusic.loop = true;
  backgroundMusic.volume = 0.3;
  let isMusicPlaying = false;

  // –ö–Ω–æ–ø–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—É–∑—ã–∫–æ–π
  const musicToggle = document.createElement('button');
  musicToggle.id = 'music-toggle';
  musicToggle.innerHTML = 'üîá';
  musicToggle.style.position = 'absolute';
  musicToggle.style.bottom = '20px';
  musicToggle.style.right = '20px';
  musicToggle.style.zIndex = '30';
  musicToggle.style.fontSize = '24px';
  musicToggle.style.background = 'rgba(0,0,0,0.5)';
  musicToggle.style.border = '2px solid white';
  musicToggle.style.borderRadius = '50%';
  musicToggle.style.width = '50px';
  musicToggle.style.height = '50px';
  musicToggle.style.cursor = 'pointer';
  document.body.appendChild(musicToggle);

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –¥–ª—è –º—É–∑—ã–∫–∏
  musicToggle.addEventListener('click', () => {
    isMusicPlaying = !isMusicPlaying;
    if (isMusicPlaying) {
      backgroundMusic.play().catch(e => console.log("Music error:", e));
      musicToggle.innerHTML = 'üîä';
    } else {
      backgroundMusic.pause();
      musicToggle.innerHTML = 'üîá';
    }
    localStorage.setItem('musicState', isMusicPlaying);
  });
  // ===== –ö–û–ù–ï–¶ –î–û–ë–ê–í–õ–ï–ù–ò–Ø =====
  
  // Game objects
  let bucket = { 
    x: 200, 
    y: 500, 
    width: 100,
    height: 80,
    color: '#FF5722'
  };
  
  let memes = [];
  let bombs = [];
  let memeImages = [];
  let bombImage = new Image();
  let particles = [];
  let floatingTexts = [];
  
  // –í–∞—à–∏ –∑–≤—É–∫–∏
  const sounds = {
  catch: new Audio('sounds/catch.mp3'),
  bomb: new Audio('sounds/bomb.mp3'),
  gameOver: new Audio('sounds/gameover.mp3'),
  highScore: new Audio('sounds/highscore.mp3')
};
  
  // Meme types with different rarities
  const memeTypes = [
    { name: "–ñ–¥—É–Ω", rarity: 1, points: 10 },
    { name: "popcat", rarity: 1, points: 10 },
    { name: "–î–æ–∂–¥—å –∏–∑ –º—É–∂–∏–∫–æ–≤", rarity: 2, points: 20 },
    { name: "–°–µ—Ä—å—ë–∑–Ω—ã–π –∫–æ—Ç", rarity: 2, points: 20 },
    { name: "–¢—Ä–æ–ª–ª—Ñ–µ–π—Å", rarity: 3, points: 30 },
    { name: "–ô–æ–¥–∞", rarity: 3, points: 30 },
    { name: "–î–æ–≥–µ", rarity: 4, points: 50 },
    { name: "Pepe", rarity: 5, points: 100 },
    { name: "Harold", rarity: 5, points: 100 },
    { name: "–¢—É–Ω —Ç—É–Ω —Ç—É–Ω –°–∞—Ö—É—Ä", rarity: 10, points: 200 }
  ];
  
  // Load images
  function loadImages() {
    // –í–∞—à–∏ –º–µ–º-–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const memeUrls = [
      'https://steamuserimages-a.akamaihd.net/ugc/90472493367987320/2F4D0894F18F0C96AA64DA536DB0445FF62DB709/?imw=512&amp;imh=685&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=true', // –ñ–¥—É–Ω
      'https://www.pngmart.com/files/23/Pop-Cat-PNG-Isolated-HD.png', // –ö–æ—Ç-–∫—Ä–∏—á–∞–ª–∫–∞
      'https://cdna.artstation.com/p/assets/images/images/034/163/438/large/james-busby-big-image.jpg?1611582008', // –î–æ–∂–¥—å –∏–∑ –º—É–∂–∏–∫–æ–≤
      'https://i.pinimg.com/originals/4b/dd/56/4bdd56ee84ddb2dc7b1aea998258930f.png', // –°–µ—Ä—å—ë–∑–Ω—ã–π –∫–æ—Ç
      'https://steamuserimages-a.akamaihd.net/ugc/1818895633364928244/3E8E8742F2A8764BFC6763E6D4357A7BFFC17423/?imw=512&amp;imh=412&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=true', // –¢—Ä–æ–ª–ª—Ñ–µ–π—Å
      'https://www.pngmart.com/files/12/Star-Wars-Master-Yoda-PNG-Transparent-Image.png', // –ô–æ–¥–∞
      'https://i.redd.it/vwyllr9wy8271.png', // Doge
      'https://wallpapers.com/images/high/smug-pepe-the-frog-meme-i9skbogmokgpngux.png', // Pepe
      'https://i-a.d-cd.net/lxhiT1u6Y8GnXWwfhg0e-pAd5Y0-1920.jpg', // Harold
      'https://tr.rbxcdn.com/180DAY-e7bf6d75c8753c56a2be9d55ec98fe47/420/420/Image/Png/noFilter'  // —Ç—É–Ω —Ç—É–Ω —Ç—É–Ω —Å–∞—Ö—É—Ä
    ];
    
    memeUrls.forEach(url => {
      const img = new Image();
      img.src = url;
      memeImages.push(img);
    });
    
    // –í–∞—à–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±–æ–º–±—ã
    bombImage.src = 'https://www.pngplay.com/wp-content/uploads/6/Animated-Bomb-Transparent-Free-PNG.png';
  }
  
  // Resize canvas to fit window
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bucket.y = canvas.height - 100;
    bucket.x = canvas.width / 2 - bucket.width / 2;
  }
  
  window.addEventListener('resize', resize);
  resize();
  
  // Create a new meme with random properties
  function spawnMeme() {
    // 20% chance to spawn bomb instead of meme
    if (Math.random() < 0.2) {
      spawnBomb();
      return;
    }
    
    // Choose meme type based on rarity
    let memeType;
    const roll = Math.random() * 100;
    
    if (roll < 40) {
      memeType = memeTypes[0]; // Common
    } else if (roll < 70) {
      memeType = memeTypes[1]; // Common
    } else if (roll < 85) {
      memeType = memeTypes[2]; // Uncommon
    } else if (roll < 95) {
      memeType = memeTypes[3]; // Uncommon
    } else if (roll < 98) {
      memeType = memeTypes[4]; // Rare
    } else {
      memeType = memeTypes[Math.floor(Math.random() * memeTypes.length)]; // Very rare
    }
    
    const size = 50 + Math.random() * 50;
    const memeIndex = memeTypes.findIndex(m => m.name === memeType.name);
    
    memes.push({
      x: Math.random() * (canvas.width - size),
      y: -size,
      width: size,
      height: size,
      speed: 2 + Math.random() * 3,
      type: memeType,
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      wobble: Math.random() * 5,
      wobbleSpeed: Math.random() * 0.1,
      time: 0,
      image: memeImages[memeIndex],
      isBomb: false
    });
  }
  
  // Create a bomb
  function spawnBomb() {
    const size = 60;
    
    bombs.push({
      x: Math.random() * (canvas.width - size),
      y: -size,
      width: size,
      height: size,
      speed: 3 + Math.random() * 2,
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.2,
      time: 0,
      image: bombImage,
      isBomb: true
    });
  }
  
  // Create particles for effects
  function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 5 + 2;
      
      particles.push({
        x: x,
        y: y,
        size: Math.random() * 8 + 3,
        color: color,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 30 + Math.random() * 30,
        opacity: 1
      });
    }
  }
  
  // Create explosion effect
  function createExplosion(x, y) {
    const explosion = document.createElement('div');
    explosion.className = 'explosion';
    explosion.style.left = `${x - 50}px`;
    explosion.style.top = `${y - 50}px`;
    document.body.appendChild(explosion);
    
    // Remove after animation
    setTimeout(() => {
      explosion.remove();
    }, 500);
    
    // Play your bomb sound
    sounds.bomb.play().catch(e => console.log("Sound error:", e));
  }
  
  // Create floating text
  function createFloatingText(text, x, y, color) {
    floatingTexts.push({
      text: text,
      x: x,
      y: y,
      color: color,
      life: 100
    });
  }
  
  // Draw the bucket
  function drawBucket() {
    // Bucket body
    ctx.fillStyle = bucket.color;
    ctx.beginPath();
    ctx.moveTo(bucket.x, bucket.y);
    ctx.lineTo(bucket.x + bucket.width, bucket.y);
    ctx.lineTo(bucket.x + bucket.width - 20, bucket.y + bucket.height);
    ctx.lineTo(bucket.x + 20, bucket.y + bucket.height);
    ctx.closePath();
    ctx.fill();
    
    // Bucket rim
    ctx.strokeStyle = '#FFC107';
    ctx.lineWidth = 5;
    ctx.stroke();
    
    // Bucket handle
    ctx.beginPath();
    ctx.moveTo(bucket.x + 20, bucket.y + 10);
    ctx.quadraticCurveTo(
      bucket.x + bucket.width / 2, 
      bucket.y - 30, 
      bucket.x + bucket.width - 20, 
      bucket.y + 10
    );
    ctx.stroke();
  }
  
  // Update and draw all game objects
  function update() {
    const now = Date.now();
    
    // Clear canvas with semi-transparent background for motion blur effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw background pattern
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    for (let i = 0; i < 50; i++) {
      ctx.fillRect(
        Math.random() * canvas.width,
        Math.random() * canvas.height,
        2, 2
      );
    }
    
    // Spawn new objects periodically
    if (gameRunning && now - lastSpawnTime > 500 - Math.min(score, 500) / 3) {
      spawnMeme();
      lastSpawnTime = now;
    }
    
    // Draw bucket
    drawBucket();
    
    // Update and draw memes
    for (let i = memes.length - 1; i >= 0; i--) {
      const meme = memes[i];
      
      // Update position and rotation
      meme.y += meme.speed;
      meme.rotation += meme.rotationSpeed;
      meme.time += 0.1;
      meme.wobble = Math.sin(meme.time * meme.wobbleSpeed) * 5;
      
      // Draw with rotation and wobble
      ctx.save();
      ctx.translate(meme.x + meme.width/2, meme.y + meme.height/2);
      ctx.rotate(meme.rotation);
      
      if (meme.image && meme.image.complete) {
        ctx.drawImage(
          meme.image, 
          -meme.width/2 + meme.wobble, 
          -meme.height/2, 
          meme.width, 
          meme.height
        );
      } else {
        // Placeholder
        ctx.fillStyle = getRandomColor();
        ctx.fillRect(
          -meme.width/2 + meme.wobble, 
          -meme.height/2, 
          meme.width, 
          meme.height
        );
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          -meme.width/2 + meme.wobble, 
          -meme.height/2, 
          meme.width, 
          meme.height
        );
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px Arial';
        ctx.fillText(
          meme.type.name, 
          -meme.width/2 + meme.wobble + 5, 
          -meme.height/2 + 15
        );
      }
      
      ctx.restore();
      
      // Check collision with bucket
      if (
        meme.y + meme.height > bucket.y &&
        meme.x + meme.width > bucket.x &&
        meme.x < bucket.x + bucket.width &&
        meme.y + meme.height < bucket.y + bucket.height
      ) {
        // Meme caught!
        createParticles(
          meme.x + meme.width/2, 
          meme.y + meme.height/2, 
          getRandomColor(), 
          20
        );
        
        createFloatingText(
          `+${meme.type.points} ${meme.type.name.toUpperCase()}!`,
          meme.x + meme.width/2,
          meme.y,
          getRandomColor()
        );
        
        memes.splice(i, 1);
        score += meme.type.points;
        scoreElement.textContent = `${score} –ú–ï–ú–û–í`;
        
        // Animate score
        scoreElement.style.transform = 'translateX(-50%) scale(1.3) rotate(5deg)';
        setTimeout(() => {
          scoreElement.style.transform = 'translateX(-50%) scale(1) rotate(0)';
        }, 200);
        
        // Play your catch sound
        sounds.catch.play().catch(e => console.log("Sound error:", e));
      } else if (meme.y > canvas.height + meme.height) {
        // Meme missed
        memes.splice(i, 1);
      }
    }
    
    // Update and draw bombs
    for (let i = bombs.length - 1; i >= 0; i--) {
      const bomb = bombs[i];
      
      // Update position and rotation
      bomb.y += bomb.speed;
      bomb.rotation += bomb.rotationSpeed;
      bomb.time += 0.1;
      
      // Draw with rotation
      ctx.save();
      ctx.translate(bomb.x + bomb.width/2, bomb.y + bomb.height/2);
      ctx.rotate(bomb.rotation);
      
      if (bomb.image && bomb.image.complete) {
        ctx.drawImage(
          bomb.image, 
          -bomb.width/2, 
          -bomb.height/2, 
          bomb.width, 
          bomb.height
        );
      } else {
        // Placeholder
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(0, 0, bomb.width/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.fillText('–ë–û–ú–ë–ê', -20, 5);
      }
      
      ctx.restore();
      
      // Check collision with bucket
      if (
        bomb.y + bomb.height > bucket.y &&
        bomb.x + bomb.width > bucket.x &&
        bomb.x < bucket.x + bucket.width &&
        bomb.y + bomb.height < bucket.y + bucket.height
      ) {
        // Bomb caught - lose life!
        createExplosion(bomb.x + bomb.width/2, bomb.y + bomb.height/2);
        bombs.splice(i, 1);
        lives--;
        updateLivesDisplay();
        
        if (lives <= 0) {
          gameOver();
        } else {
          // Shake screen on hit
          document.body.style.animation = 'shake 0.5s';
          setTimeout(() => {
            document.body.style.animation = '';
          }, 500);
        }
      } else if (bomb.y > canvas.height + bomb.height) {
        // Bomb missed
        bombs.splice(i, 1);
      }
    }
    
    // Update and draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2; // gravity
      p.life--;
      p.opacity = p.life / 60;
      
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.opacity;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      
      if (p.life <= 0) {
        particles.splice(i, 1);
      }
    }
    ctx.globalAlpha = 1;
    
    // Update and draw floating texts
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const text = floatingTexts[i];
      
      ctx.font = 'bold 24px Comic Sans MS';
      ctx.fillStyle = text.color;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;
      ctx.strokeText(text.text, text.x, text.y);
      ctx.fillText(text.text, text.x, text.y);
      
      text.y -= 2;
      text.life--;
      
      if (text.life <= 0) {
        floatingTexts.splice(i, 1);
      }
    }
    
    if (gameRunning) {
      animationFrameId = requestAnimationFrame(update);
    }
  }
  
  // Update lives display
  function updateLivesDisplay() {
    livesElement.textContent = '‚ù§Ô∏è'.repeat(lives) + '‚ô°'.repeat(3 - lives);
    
    // Pulse effect when losing life
    livesElement.style.transform = 'scale(1.5)';
    livesElement.style.color = 'red';
    setTimeout(() => {
      livesElement.style.transform = 'scale(1)';
      livesElement.style.color = '';
    }, 300);
  }
  
  // Helper function for random colors
  function getRandomColor() {
    const colors = [
      '#FF5252', '#FFEB3B', '#4CAF50', '#2196F3', 
      '#9C27B0', '#FF9800', '#00BCD4', '#E91E63',
      '#8BC34A', '#CDDC39', '#FFC107', '#FF5722'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  // Start the game
  function startGame() {
    score = 0;
    lives = 3;
    scoreElement.textContent = `${score} –ú–ï–ú–û–í`;
    updateLivesDisplay();
    memes = [];
    bombs = [];
    particles = [];
    floatingTexts = [];
    gameRunning = true;
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    lastSpawnTime = Date.now();
    
    // Start with 3 memes
    for (let i = 0; i < 3; i++) {
      setTimeout(() => spawnMeme(), i * 500);
    }
    
    update();
  }

  // –ê–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –º—É–∑—ã–∫–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏–≥—Ä—ã
    if (localStorage.getItem('musicState') !== 'false') {
      isMusicPlaying = true;
      backgroundMusic.play().catch(e => console.log("Music error:", e));
      musicToggle.innerHTML = 'üîä';
    }
  
  // End the game
  function gameOver() {
    gameRunning = false;
    finalScoreElement.textContent = `–ü–æ–π–º–∞–Ω–æ: ${score} –º–µ–º–æ–≤`;
    gameOverScreen.style.display = 'flex';
    
    // Play your game over sound
    sounds.gameOver.play().catch(e => console.log("Sound error:", e));
    
    // Update high score
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('memeHighScore', highScore);
      highScoreElement.textContent = `–†–µ–∫–æ—Ä–¥: ${highScore}`;
      
      // Special effect for new high score
      finalScoreElement.textContent = `–ù–û–í–´–ô –†–ï–ö–û–†–î: ${highScore}!`;
      finalScoreElement.style.animation = 'rainbow 0.5s infinite';
      
      // Play your high score sound
      sounds.highScore.play().catch(e => console.log("Sound error:", e));
    }
    
    cancelAnimationFrame(animationFrameId);
  }
  
  // Event listeners
  startBtn.addEventListener('click', startGame);
  restartBtn.addEventListener('click', startGame);
  
  // Touch and mouse controls
  function handleMove(x) {
    if (!gameRunning) return;
    
    // Smooth movement with boundaries
    const targetX = Math.max(
      bucket.width/2, 
      Math.min(x - bucket.width/2, canvas.width - bucket.width/2)
    );
    bucket.x += (targetX - bucket.x) * 0.2;
  }
  
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    handleMove(touch.clientX);
  }, { passive: false });
  
  canvas.addEventListener('mousemove', e => {
    handleMove(e.clientX);
  });
  
  // Load images when page loads
  loadImages();
  
  // Resize canvas initially
  resize();
  
  // Add shake animation to styles
  const style = document.createElement('style');
  style.textContent = `
    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      70% { transform: translate(3px, 1px) rotate(-1deg); }
      80% { transform: translate(-1px, -1px) rotate(1deg); }
      90% { transform: translate(1px, 2px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }
  `;
  document.head.appendChild(style);
  
  // For Telegram Mini App integration
  if (window.Telegram && window.Telegram.WebApp) {
    // Expand the app to full viewport
    Telegram.WebApp.expand();
    
    // Change background color to match Telegram theme
    document.body.style.background = Telegram.WebApp.themeParams.bg_color || 'linear-gradient(to bottom, #ff00cc, #3333ff)';
    
    // Adjust text color based on theme
    const textColor = Telegram.WebApp.themeParams.text_color || 'white';
    document.body.style.color = textColor;
    document.querySelector('h1').style.color = textColor;
    
    // Handle back button
    Telegram.WebApp.BackButton.onClick(() => {
      if (gameRunning) {
        gameOver();
      } else {
        Telegram.WebApp.close();
      }
    });
    
    // Show back button when game starts
    startBtn.addEventListener('click', () => {
      Telegram.WebApp.BackButton.show();
    });
  }
</script>
</body>
</html>
